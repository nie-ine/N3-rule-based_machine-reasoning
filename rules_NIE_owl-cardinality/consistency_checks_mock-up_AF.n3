@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix owl: <http://www.w3.org/2002/07/owl#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix pi: <http://eulersharp.sourceforge.net/2003/03swap/pi-rules#>.
@prefix knora-base: <http://www.knora.org/ontology/knora-base#>.

# KNORA CONSISTENCY CHECKS

# Cardinality 1 Table
    {
        ?i rdf:type ?r.
?r rdfs:subClassOf [owl:onProperty ?p ;
            owl:cardinality "1"^^xsd:nonNegativeInteger] .
}
    =>
    {
        ?i ?p ?x.
}.

# Min Cardinality 1 Table
{
        ?i rdf:type ?r.
?r owl:minCardinality "1"^^xsd:nonNegativeInteger .
?r owl:onProperty ?p .
        }
    =>
    {
        ?i ?p ?r.
}.

# Max Cardinality 1 Table
{
        ?i rdf:type ?r.
?r owl:maxCardinality "1"^^xsd:nonNegativeInteger .
?r owl:onProperty ?p .

        }
    =>
    {
        ?i ?p ?r.
}.

# Disallow Empty String
{
        ?i ?p "".
        }
    =>
    {
}.

## Consistency Rules for Subject and Object Class constraints

{
        ?p knora-base:subjectClassConstraint ?t.
?i ?p ?j .
        }
    =>
    {
        ?i rdf:type ?t.
}.

{
        ?p knora-base:objectClassConstraint ?t.
?i ?p ?j .
}
    =>
    {
        ?j rdf:type ?t.
}.

## Consistency rules for cardinalities on any properties

# contex subject
{
        ?i ?p ?r .
}
    =>
    {
        ?i ?p ?j.
}.

# context object

{
        ?i ?p ?r .
}
    =>
    {
        ?i ?p ?j.
}.



#    * Consistency rules for cardinalities on properties whose objects cannot be marked as deleted
#    * using the boolean flag knora-base:isDeleted.

# With owl:maxCardinality 1, if the object of the property cannot be marked as deleted, just check that there
# is not more than one object.
# Consistency: max_cardinality_1_without_deletion_flag
{ ?i ?p ?r .
#[Context <onto:_maxCardinality_1_table>]
?p <rdfs:subPropertyOf> <knora-base:objectCannotBeMarkedAsDeleted> .

?i ?p ?j .
#[Constraint j != k]
?i ?p ?k .
#[Cut]
} =>
    { } .

# With owl:cardinality 1, if the object of the property cannot be marked as deleted, just check that there
# is not more than one object.
# Consistency: cardinality_1_not_greater_without_deletion_flag
{ ?i ?p ?r .
#[Context <onto:_cardinality_1_table>]
?p <rdfs:subPropertyOf> <knora-base:objectCannotBeMarkedAsDeleted> .

?i ?p ?j .
#[Constraint j != k]
?i ?p ?k .
#[Cut]
} => { }.


#    * Consistency rules for cardinalities on properties whose objects can be marked as deleted
#    * using the boolean flag knora-base:isDeleted. Here we take advantage of the fact that every class
#    * that *allows* knora-base:isDeleted also *requires* knora-base:isDeleted. So an object that can be
#    * marked as deleted, but has not been marked as deleted, will have knora-base:isDeleted false.

#With owl:maxCardinality 1, if the object of the property can be marked as deleted, there must not be
# more than one non-deleted object. (In other words, it's OK if there is more than one object,
# as long only one object has knora-base:isDeleted false.)													# DEPENDENCY ON 'DELETED' TRICKY BECAUSE TRIPLE 

STILL IN THE SYSTEM, JUST INVISIBLE TO USER WHO DELETED IT; SOUND IMPLEMENTATION OF CARDINALITY SEMANTICS? 


# Consistency: max_cardinality_1_with_deletion_flag
{
        ?i ?p ?r .
#[Context <onto:_maxCardinality_1_table>]
?i ?p ?j .
# [Constraint j != k]
?i ?p ?k .
#[Cut]
?j <knora-base:isDeleted> "false"^^xsd:boolean .

?k <knora-base:isDeleted> "false"^^xsd:boolean .
}
    => {} .


# With owl:cardinality 1, if the object of the property can be marked as deleted, there must not be
# more than one non-deleted object. (In other words, it's OK if there is more than one object,
# as long only one object has knora-base:isDeleted false.)
# Consistency: cardinality_1_not_greater_with_deletion_flag
 {
        ?i ?p ?r .
#[Context <onto:_cardinality_1_table>]
?i ?p ?j .
#[Constraint j != k]
?i ?p ?k .
# [Cut]
?j <knora-base:isDeleted> "false"^^xsd:boolean .

?k <knora-base:isDeleted> "false"^^xsd:boolean .
}
    =>
    {} .



# If a resource has a property pointing to a resource or value, the resource class must have
# some cardinality for that property.
# Consistency: resource_prop_cardinality_any
{?i <knora-base:resourceProperty> ?j .
}
    => {
        ?i ?p ?j .
?i <rdf:type> ?r .
?r <owl:onProperty> ?p .
} .



# If a value has a subproperty of knora-base:valueHas, the value class must have
# some cardinality for that property.
# Consistency: value_prop_cardinality_any
  {  ?i <knora-base:valueHas> ?j }
    => {
        ?i ?p ?j .
?i <rdf:type> ?r .
?r <owl:onProperty> ?p .
        } .
